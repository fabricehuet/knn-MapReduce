%\begin{abstract}
Given a point $p$ and a set of points $S$, the kNN operation finds the $k$ closest points to $p$ in $S$. It is a computational
intensive task with a large range of applications such as knowledge discovery or data mining. However, as the volume
and the dimension of data increase, only distributed approaches can perform such costly operation in a reasonable time. 
Recent works have focused on implementing efficient solutions using the MapReduce programming model because it is suitable for 
distributed large scale data processing.  Although these works provide
different solutions to the same problem, each one has particular constraints and properties. 
In this paper, we compare the different existing approaches for computing kNN on MapReduce, first theoretically, and then by performing an extensive experimental evaluation. To be able to compare solutions, we identify three generic steps for kNN computation on MapReduce: data pre-processing, data partitioning and computation. We then analyze each step from load balancing, accuracy and complexity aspects. Experiments in this paper use a variety of datasets, and analyze the impact of data volume, data dimension and the value of k from many perspectives like time and space complexity, and accuracy. The experimental part brings new advantages and shortcomings that are discussed for each algorithm. To the best of our knowledge, this is the first paper that compares kNN computing methods on MapReduce both theoretically and experimentally with the same setting. Overall, this paper can be used as a guide to tackle kNN-based practical problems in the context of big data. 
%Our results provide insights on how to chose a solution for a particular use case.
%There is no readily available 
%comparison to help users choose the one most appropriate for their needs. This is the problem we address in this work. 
%Firstly, we show that all kNN implementations go 
%through a common workflow, which we use as a basis for classification. Secondly, we describe precisely the different 
%techniques published so far. And lastly, we provide a set of objective criteria that can be used to make informed decisions.  
%
%
%MapReduce widely known as a popular parallel framework with a large 
%cluster of commodity machines has recently brought a new fashion of solving this classic problem. Hence, to speed up this 
%computation-intensive problem on a framework that is good at processing data-intensive operations still requires some 
%fantastic ideas and some practical technologies.
%
%In this paper we analysis some ways of processing kNN Join on top of MapReduce, we first present their workflow including 
%the pre-processing stage, the data organization stage and the execution stage. We then give a theoretical analysis about 
%load balance, the accuracy, the complexity and the dynamicity. At the end, we give a short summary and comparison.

% including the exact way and the approximate way, and study their strategies of data partition.  Then we compare them with some other parallel methods of processing kNN without MapReduce. We also consider about the dynamicity of the processing model to see whether they are efficient or not when some updates of the input data occur. 

%This paper compares some methods about processing kNN joins on MapReduce, including the exact kNN join and the approximate kNN join. We also study about the partition method for processing kNN joins on MapReduce, and calculate the different costs of computation and data shuffle under different partition strategies.
%\end{abstract}